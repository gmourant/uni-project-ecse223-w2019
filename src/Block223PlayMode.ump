class Block223 {
   1 <@>- * PlayedGame playedGames;
   1 <@>- * HallOfFameEntry entries;
}

class Game {
   lazy Boolean published; // Cannot edit a published game
   // Author: Kelly Ma
   after addHallOfFameEntry {
   		mostRecentEntry = aHallOfFameEntry; // Sets the newest entry as the mostRecentEntry
   }
	before setPublished {
		if (published) return wasSet;
	}
   1 -> 0..1 HallOfFameEntry mostRecentEntry;
  /*This method returns a block for the doSetup() method*/
  /*@author : Imane Chafi*/
   public Block getRandomBlock(){
   	List<Block> blocks = this.getBlocks();
	Block block = this.getBlock(0);
  	return block;
   }
}

class PlayedGame {
   const Integer INITIAL_WAIT_TIME = 70; // at design time, the initial wait time may be adjusted as seen fit
   autounique id;
   const Integer NR_LIVES = 3;
   Integer score = 0;
   Integer lives = NR_LIVES;
   Integer currentLevel = 1;
   Double waitTime = INITIAL_WAIT_TIME;
   * -- 0..1 Player player; // an admin may test the game; a game is played in test mode if player == null
   playername; // added here so that it only needs to be determined once
   
   // the PlayedBall and PlayedPaddle are not in a separate class to avoid the bug in Umple that occurred for the second constructor of Game

   // no direct link to Ball, because the ball can be found by navigating to PlayedGame, Game, and then Ball
   const Integer BALL_INITIAL_X = Game.PLAY_AREA_SIDE / 2;
   const Integer BALL_INITIAL_Y = Game.PLAY_AREA_SIDE / 2;
   // 0/0 is the top left corner of the play area, i.e., a directionX/Y of 0/1 moves the ball down in a straight line
   defaulted Double ballDirectionX = getGame().getBall().getMinBallSpeedX();
   defaulted Double ballDirectionY = getGame().getBall().getMinBallSpeedY();
   // the position of the ball is at the center of the ball
   defaulted Double currentBallX = BALL_INITIAL_X;
   defaulted Double currentBallY = BALL_INITIAL_Y;

   // no direct link to Paddle, because the paddle can be found by navigating to PlayedGame, Game, and then Paddle
   const Integer PADDLE_MOVE_RIGHT = 5; // pixels moved when right arrow key is pressed
   const Integer PADDLE_MOVE_LEFT = -5; // pixels moved when left arrow key is pressed
   Double currentPaddleLength = getGame().getPaddle().getMaxPaddleLength();
   // the position of the paddle is at its top right corner
   defaulted Double currentPaddleX = (Game.PLAY_AREA_SIDE - currentPaddleLength) / 2;
   immutable Double currentPaddleY = Game.PLAY_AREA_SIDE - Paddle.VERTICAL_DISTANCE - Paddle.PADDLE_WIDTH;

   * -- 1 Game game;
   1 <@>- * PlayedBlockAssignment blocks;
   0..1 -> 0..1 BouncePoint bounce;
   
   before setBallDirectionX { // Divide by 2 if speed is over 10
   		if (aBallDirectionX >= 8) aBallDirectionX /= 2.0;
   }
   
   before setBallDirectionY { // Divide by 2 if speed is over 10
   		if (aBallDirectionY >= 8) aBallDirectionY /= 2.0;
   }
   
   // Author: Kelly Ma
   public HallOfFameEntry getMostRecentEntry() { // Returns a game's most recent HallOfFameEntry
		// Obtain game associated with this PlayedGame
		return this.getGame().getMostRecentEntry();
   }
   
   // Author: Kelly Ma
   public int indexOfHallOfFameEntry() { // Returns the index of a game's mostRecentEntry
		HallOfFameEntry mostRecentEntry = this.getMostRecentEntry(); // Obtain most recent entry
		List<HallOfFameEntry> entries = this.getGame().getHallOfFameEntries(); // Get list of all entries
		int index = 0; // Start index at 0
		for (HallOfFameEntry entry : entries) {
			if (entry == mostRecentEntry) break; // Break if mostRecentEntry is found
			index++; // Increase index after each iteration of loop
		}
		return index; // Return index of most recent entry
	}
	
	before constructor {
      boolean didAddGameResult = setGame(aGame);
      if (!didAddGameResult)
      {
         throw new RuntimeException("Unable to create playedGame due to game");
      }
   }
}

class PlayedBlockAssignment {
   // the associated block is either (a) the same as the one of the corresponding BlockAssignent or (b) randomly chosen
   * -- 1 Block block;
   // the position of a block is at its top right corner
   Integer x;
   Integer y;
}

class HallOfFameEntry {
   Integer score;
   playername; // added here so that it only needs to be determined once
   * -- 1 Player player;
   // the sorted keyword keeps the list of entries in the game automatically sorted by the score
   * sorted {score} -- 1 Game game;
}

// this class needs to be specified but the use of it is optional; it is also not added to the persistence file
// you may implement bounce behavior differently
class BouncePoint {
   Double x;
   Double y;
   enum BounceDirection { FLIP_X, FLIP_Y, FLIP_BOTH }
   BounceDirection direction;
   0..1 -> 0..1 PlayedBlockAssignment hitBlock;
}
