class PlayedGame {

  depend ca.mcgill.ecse223.block.model.BouncePoint.BounceDirection;
  depend math.geom2d.Point2D;
  depend math.geom2d.conic.Circle2D;
  depend math.geom2d.line.LineSegment2D;
  depend math.geom2d.polygon.Rectangle2D;

  // State Machine
  
  playStatus {
    Ready {
      entry / { doSetup(); }
      play -> Moving;
    }
    Moving {
      pause -> Paused;
      move [hitPaddle()] / { doHitPaddleOrWall(); } -> Moving;
      move [isOutOfBoundsAndLastLife()] / { doOutOfBounds(); } -> GameOver;
      move [isOutOfBounds()] / { doOutOfBounds(); } -> Paused;
      move [hitLastBlockAndLastLevel()] / { doHitBlock(); } -> GameOver;
      move [hitLastBlock()] / { doHitBlockNextLevel(); } -> Ready;
      move [hitBlock()] / { doHitBlock(); } -> Moving;
      move [hitWall()] / { doHitPaddleOrWall(); } -> Moving;
      move / { doHitNothingAndNotOutOfBounds(); } -> Moving;
    }
    Paused {
      play -> Moving;
    }
    GameOver {
      entry / { doGameOver(); }
    }
  }
  
  // Guards
  
 /**
   * This returns true if the ball hits the paddle.
   * @author Kelly Ma
   * @return Whether or not the ball hits paddle
  */
  private boolean hitPaddle() {
    BouncePoint bp = calculateBouncePointPaddle();
    setBounce(bp);
    if (bp != null) return true;
    return false;
  }

  /**
   * This returns true if the ball is out of bounds and is last life.
   * @author Georges Mourant
   * @return if ball is out of bounds and last life
  */
  private boolean isOutOfBoundsAndLastLife() {
    boolean outOfBounds = false;
    if(lives == 1) outOfBounds = isBallOutOfBounds();
    return outOfBounds;
  }
  
  /**
   * This returns true if the ball is out of bounds.
   * @author Georges Mourant
   * @return if ball is out of bounds and last life
  */
  private boolean isOutOfBounds() {
    return isBallOutOfBounds();
  }
  
  private boolean hitLastBlockAndLastLevel() {
    Game game = getGame();
    int nrLevels = game.numberOfLevels();
    setBounce(null);
    if (nrLevels == currentLevel) {
        int nrBlocks = numberOfBlocks();
        if (nrBlocks == 1) {
            PlayedBlockAssignment block = getBlock(0);
            BouncePoint bp = calculateBouncePointBlock(block);
            setBounce(bp);
            return true;
        }
    }
    return false;
  }
  
  /**
  * This method returns true if the ball hits the last block.
  * @author Mathieu Bissonnette
  */
  
  private boolean hitLastBlock(){
    int nrBlocks = numberOfBlocks();
    setBounce(null);
    if (nrBlocks == 1) {
        PlayedBlockAssignment block = getBlock(0);
        BouncePoint bp = calculateBouncePointBlock(block);
        setBounce(bp);
        return true;
    }
    return false;
  }
  
  /**
  * This method returns true if the ball hits a block.
  * @author Mathieu Bissonnette
  */
  
  private boolean hitBlock() {
    int nrBlocks = numberOfBlocks();
    setBounce(null);
    for (int i = 0; i <= (nrBlocks - 1); i++) {
        PlayedBlockAssignment block = getBlock(i);
        BouncePoint bp = calculateBouncePointBlock(block);
        bounce = getBounce();
        boolean closer = isCloser(bp, bounce);
        if (closer)
            setBounce(bp);
    }
    return (getBounce() != null);
  }
  
   /**
   * This returns true if the ball hits a wall.
   * @author Kelly Ma
   * @return Whether or not the ball hits wall
  */
  private boolean hitWall() {
    BouncePoint bp = calculateBouncePointWall();
    setBounce(bp);
    if (bp != null) return true;
    return false;
  }
  
  // Actions
  
/**
 	 * Public method used to get a random number
 	 * @author https://dzone.com/articles/random-number-generation-in-java
 	 * @return double value
 	 * */
 	public static int getRandomInt(){
 	    Random rand = new Random();
 		//obtain number between 0-49
 	    int x = rand.nextInt(50);
 	    return x;
 	}
 	public static int getRandomInt2(){
 	    Random rand = new Random();
 		//obtain number between 0-4
 	    int x = rand.nextInt(4);
 	    return x;
 	}
	
		/**
 	 * This private method returns the setup for the Played Game
 	 * by resetting the ball positions and paddle positions and by
 	 * adding random block positions if there is less blocks than the 
 	 * set number of blocks/level.
 	 * @author Imane Chafi 
 	 * */
 	private void doSetup() {
	
 		this.resetCurrentBallX();
 		this.resetCurrentBallY();
 		this.resetBallDirectionX();
 		this.resetBallDirectionY();
 		this.resetCurrentPaddleX();
 		this.getGame();
 		Level level = game.getLevel(getCurrentLevel()-1);
 		List <BlockAssignment> assignments = level.getBlockAssignments();
 		
 	
 		for(BlockAssignment a : assignments) {
 			PlayedBlockAssignment pblock = new PlayedBlockAssignment(Game.WALL_PADDING + (Block.SIZE + Game.COLUMNS_PADDING)*(a.getGridHorizontalPosition()-1), Game.WALL_PADDING + (Block.SIZE + Game.ROW_PADDING)*(a.getGridVerticalPosition() - 1), a.getBlock(), this);
 			
 		}
 		//Initializing the x and y variables before the while loop
 			int x = getRandomInt();
 			int y = getRandomInt();
 			BlockAssignment randomgridPositionX;
 			BlockAssignment randomgridPositionY;
 		while(numberOfBlocks() < game.getNrBlocksPerLevel()) {
 			//if chosen, try next position starting from randomly chosen position
 			BlockAssignment taken = level.findBlockAssignment(x, y);
 				if(taken !=null){
 					x++;
 				if(x > 15){
 					y++;
 				x = 1;
 				}
 				if(y>15)
 				y = 1;
 				
 			}
 			//going to the right, then next row until last row
 			//then 1/1 until empty position found.
 			//convert to x/y coordinates
 			x = Game.WALL_PADDING + (Block.SIZE + Game.COLUMNS_PADDING)*(x-1);
 			y = Game.WALL_PADDING + (Block.SIZE + Game.ROW_PADDING)*(y-1);

 			
 			PlayedBlockAssignment pblock = new PlayedBlockAssignment(x,y,game.getRandomBlock(), this);
 			//addBlock(pblock);
 	}
 	}
  
  private void doHitPaddleOrWall() {
    bounceBall();
  }

  private void doOutOfBounds() {
    setLives(lives-1);
    resetCurrentBallX();
    resetCurrentBallY();
    resetBallDirectionX();
    resetBallDirectionY();
    resetCurrentPaddleX();
  }

  private void doHitBlock() {
    int score = getScore();
    BouncePoint bounce = getBounce();
    PlayedBlockAssignment pblock = bounce.getHitBlock();
    Block block = pblock.getBlock();
    int bscore = block.getPoints();
    setScore(score + bscore);
    pblock.delete();
    bounceBall();
  }

  private void doHitBlockNextLevel() {
    doHitBlock();
    int level = getCurrentLevel();
    setCurrentLevel(level + 1);
    Paddle paddle = getGame().getPaddle();
    int length = paddle.getMaxPaddleLength() 
            - (paddle.getMaxPaddleLength() - paddle.getMinPaddleLength())
            / (getGame().numberOfLevels() - 1) 
            * (getCurrentLevel() - 1);
    setCurrentPaddleLength(length);
    setWaitTime(INITIAL_WAIT_TIME 
            * Math.pow(getGame().getBall().getBallSpeedIncreaseFactor(),
            (getCurrentLevel() - 1)));
  }

 /**
   * This method is performed when the ball is bounced after hitting the paddle, block, or wall.
   * @author Kelly Ma
  */
	private void bounceBall(){
		BouncePoint bp = getBounce(); // Calculate bounce point
			double newBallDirectionX = ballDirectionX; // Create variables to store new X & Y directions
			double newBallDirectionY = ballDirectionY;
		if (bp.getDirection().equals(BouncePoint.BounceDirection.FLIP_Y)) { // Check direction at bounce point
			newBallDirectionY = -1 * ballDirectionY; // Flip Y direction
			if (ballDirectionX * ballDirectionY < 0) { // Check if product of X and Y direction is < 0
				newBallDirectionX = ballDirectionX + 0.1 * newBallDirectionY; 
			}
			else {
				newBallDirectionX = ballDirectionX + 0.1 * ballDirectionY;
			}			 
		} else if (bp.getDirection().equals(BouncePoint.BounceDirection.FLIP_X)) { // Check direction at bounce point
			newBallDirectionX = -1 * ballDirectionX; // Flip X direction
			if (ballDirectionX * ballDirectionY < 0) { // Check if product of X and Y direction is < 0
				newBallDirectionY = ballDirectionY + 0.1 * newBallDirectionX; 
			}
			else {
				newBallDirectionY = ballDirectionY + 0.1 * ballDirectionX;
			}
		} else if (bp.getDirection().equals(BouncePoint.BounceDirection.FLIP_BOTH)) { // Check if both are flipped
			newBallDirectionX = -1 * ballDirectionX;
			newBallDirectionY = -1 * ballDirectionY;
		}
		
		setCurrentBallY(bp.getY()); // Set current ball positions
		setCurrentBallX(bp.getX());
		setBallDirectionX(newBallDirectionX); // Set new ball directions
		setBallDirectionY(newBallDirectionY);
		
		if (bp.hasHitBlock()) { // Check if the bounce point has a block
			bounce.setHitBlock(null);
		}
	}

/*Method calculateBouncePointPaddle sets the flip states of the ball 
  when it hits the paddle.
  @author Imane Chafi
  @return BouncePoint*/
  
   private BouncePoint calculateBouncePointPaddle(){
	   /* STEP 1 : Check  if  the  ball  segment (the  segment  determined  by 
	   the  current  position  of  the  ball  and  the  new position of the 
	   ball) intersects with the full box (A, B, C, E,F)*/
	   
	   int radius = Ball.BALL_DIAMETER/2; // Get ball radius
	   BouncePoint bp = null; // Initialize ball's bounce point
	   double currentBallX = this.getCurrentBallX(); // Find ball coordinates
	   double currentBallY = this.getCurrentBallY();
	   double nextBallX = currentBallX + this.getBallDirectionX();
	   double nextBallY = currentBallY + this.getBallDirectionY();
	   
	   // Find rectangles for calculation purposes
	 	Rectangle2D.Double rectA = new Rectangle2D.Double(currentPaddleX, Paddle.VERTICAL_DISTANCE - radius, Paddle.PADDLE_WIDTH, radius ); // Left wall of play area
	 	Rectangle2D.Double rectB = new Rectangle2D.Double(currentPaddleX - radius, Paddle.VERTICAL_DISTANCE, radius, radius); // Top wall of play area
	 	Rectangle2D.Double rectC = new Rectangle2D.Double(currentPaddleX + Paddle.PADDLE_WIDTH, Paddle.VERTICAL_DISTANCE, radius, radius); // Right wall of play area
	 	Rectangle2D.Double rectE = new Rectangle2D.Double(currentPaddleX - radius, Paddle.VERTICAL_DISTANCE - radius, radius, radius); // Right wall of play area
	 	Rectangle2D.Double rectF = new Rectangle2D.Double(currentPaddleX + Paddle.PADDLE_WIDTH, Paddle.VERTICAL_DISTANCE - radius, radius, radius); // Right wall of play area
	 // create new QuadCurve2D.Float for E 
		QuadCurve2D curveE = new QuadCurve2D.Float();
		curveE.setCurve(currentPaddleX - radius, Paddle.VERTICAL_DISTANCE, currentPaddleX - ((int)(radius/(Math.sqrt(2)))), Paddle.VERTICAL_DISTANCE - ((int)(radius/(Math.sqrt(2)))), currentPaddleX, Paddle.VERTICAL_DISTANCE - radius);
	 // create new QuadCurve2D.Float for F
		QuadCurve2D curveF = new QuadCurve2D.Float();
		curveF.setCurve(currentPaddleX + Paddle.PADDLE_WIDTH + radius, Paddle.VERTICAL_DISTANCE, currentPaddleX + Paddle.PADDLE_WIDTH + ((int)(radius/(Math.sqrt(2)))), Paddle.VERTICAL_DISTANCE - ((int)(radius/(Math.sqrt(2)))), currentPaddleX + Paddle.PADDLE_WIDTH, Paddle.VERTICAL_DISTANCE - radius);
		// Check points of intersection between ball and lines
	 	boolean intersectionA = rectA.intersectsLine(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectA
	 	boolean intersectionB = rectB.intersectsLine(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectB
	 	boolean intersectionC = rectC.intersectsLine(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectC
	 	boolean intersectionE = rectE.intersectsLine(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectB
	 	boolean intersectionF = rectF.intersectsLine(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectC
	 	boolean intersectionECurve = curveE.intersects(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectB
	 	boolean intersectionFCurve = curveF.intersects(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectC
	   
	 	/*STEP 2 : For A, B, C, determine the bounce point by intersecting the
	    ball segment with each of the yellow line segments of A, B,*/
	 // Create a collection of bounce points to determine which is closest
	 		List <BouncePoint> bouncePoints = new ArrayList<BouncePoint>();
	 		
	 		if (!intersectionA && !intersectionB && !intersectionC) { // Does not hit a hall at all
				return null;
			} else if (intersectionA) { // Check intersection of A 
				bp = new BouncePoint(nextBallX, nextBallY, BouncePoint.BounceDirection.FLIP_Y);//X and Y position are set to the same nextBallX and nextBallY
				bouncePoints.add(bp);
			} else if (intersectionB) { // Check intersection of B 
				bp = new BouncePoint(nextBallX, nextBallY, BouncePoint.BounceDirection.FLIP_X);
				bouncePoints.add(bp);
			} else if (intersectionC) { // Check intersection of C
				bp = new BouncePoint(nextBallX, nextBallY, BouncePoint.BounceDirection.FLIP_X);
				bouncePoints.add(bp);
			}
	 		
	 		/*STEP  3:  For  E,  F  determine  the 
	    bounce  point  by  intersecting  the  ball  segment  
	    with  each  of the  circle  segments of E, */
			else if (intersectionE || intersectionECurve) { // Check intersection of C
				
				//Setting the curve for E : 
				bp = new BouncePoint(nextBallX, nextBallY, BouncePoint.BounceDirection.FLIP_X);
				bouncePoints.add(bp);
			}
			else if (intersectionF || intersectionFCurve) { // Check intersection of C
				bp = new BouncePoint(nextBallX, nextBallY, BouncePoint.BounceDirection.FLIP_X);
				bouncePoints.add(bp);
			}
	 		
	    /*: If more than one bounce point are found, 
	    take the bounce point that is the closest to the 
	    current position of the ball. 
	    The box of the bounce point determines the bounce behavior */
	 	// Iterate through all points to find the closest one
			BouncePoint closestPoint = null;
	        for (BouncePoint bouncePoint : bouncePoints) {
	        	if (isCloser(bouncePoint, closestPoint))
	            	closestPoint = bouncePoint;
	        }

			return closestPoint; // From collection of all bounce points
	   }


  /**
  * This method returns the bounce point that is the closest to the ball. 
  * If there is no bouncePoint, it returns null.
  * @author Mathieu Bissonnette
  */
  
   private BouncePoint calculateBouncePointBlock(PlayedBlockAssignment block){
    // Construct the collision box.
       int gridHorizontalCoordinate = block.getX();
       int gridVerticalCoordinate = block.getY();
       int boxTopLeftX = 10+15*(gridHorizontalCoordinate-1);
       int boxTopLeftY = 10+12*(gridVerticalCoordinate-1);
       // verify if the ball hits the collision box.
       Rectangle2D collisionBox = new Rectangle2D(boxTopLeftX,boxTopLeftY,30,30);
       LineSegment2D ballDirection = new LineSegment2D(currentBallX, currentBallY, currentBallX+ballDirectionX, currentBallX+ballDirectionY);
       Collection<LineSegment2D> edges = collisionBox.edges();
       Boolean intersection = false;
       for (LineSegment2D line : edges) {
           intersection = !(LineSegment2D.getIntersection(line, ballDirection).isEmpty());
       }
       if (intersection) {
           // find border bounce point.
           Collection<BouncePoint> bouncePoints = new ArrayList<BouncePoint>();
           Point2D edgeIntersectionPoint = LineSegment2D.getIntersection(ballDirection,new LineSegment2D(boxTopLeftX+5, boxTopLeftY, boxTopLeftX+25, boxTopLeftY));
           if (edgeIntersectionPoint != null) {
               BouncePoint bpA = new BouncePoint(edgeIntersectionPoint.getX(), edgeIntersectionPoint.getY(), BounceDirection.FLIP_Y);
               bouncePoints.add(bpA);
           }
           edgeIntersectionPoint = LineSegment2D.getIntersection(ballDirection,new LineSegment2D(boxTopLeftX, boxTopLeftY+5, boxTopLeftX, boxTopLeftY+25));
           if (edgeIntersectionPoint != null) {
               BouncePoint bpB = new BouncePoint(edgeIntersectionPoint.getX(), edgeIntersectionPoint.getY(), BounceDirection.FLIP_X);
               bouncePoints.add(bpB);
           }
           edgeIntersectionPoint = LineSegment2D.getIntersection(ballDirection,new LineSegment2D(boxTopLeftX+30, boxTopLeftY+5, boxTopLeftX+30, boxTopLeftY+25));
           if (edgeIntersectionPoint != null) {
               BouncePoint bpC = new BouncePoint(edgeIntersectionPoint.getX(), edgeIntersectionPoint.getY(), BounceDirection.FLIP_X);
               bouncePoints.add(bpC);
           }
           edgeIntersectionPoint = LineSegment2D.getIntersection(ballDirection,new LineSegment2D(boxTopLeftX+5, boxTopLeftY+30, boxTopLeftX+25, boxTopLeftY+30));
           if (edgeIntersectionPoint != null) {
               BouncePoint bpD = new BouncePoint(edgeIntersectionPoint.getX(), edgeIntersectionPoint.getY(), BounceDirection.FLIP_Y);
               bouncePoints.add(bpD);
           }
           
           //Then add corner points
           
           Circle2D upperLeftCorner = new Circle2D(boxTopLeftX+5, boxTopLeftY+5, 5);
           Circle2D lowerLeftCorner = new Circle2D(boxTopLeftX+5, boxTopLeftY+25, 5);
           Circle2D upperRightCorner = new Circle2D(boxTopLeftX+25, boxTopLeftY+5, 5);
           Circle2D lowerRightCorner = new Circle2D(boxTopLeftX+25, boxTopLeftY+25, 5);
           Collection<Point2D> cornerIntersectionPoints = upperLeftCorner.intersections(ballDirection);
           cornerIntersectionPoints.addAll(lowerLeftCorner.intersections(ballDirection));
           cornerIntersectionPoints.addAll(upperRightCorner.intersections(ballDirection));
           cornerIntersectionPoints.addAll(lowerRightCorner.intersections(ballDirection));

           for (Point2D point : cornerIntersectionPoints) {
               bouncePoints.add(new BouncePoint(point.getX(), point.getY(), BounceDirection.FLIP_BOTH));
           }
           
           //Then iterated through the collection to find the closest bounce point.
           
           BouncePoint closestPoint = null;
           for (BouncePoint bouncePoint : bouncePoints) {
               if (isCloser(bouncePoint,closestPoint))
                   closestPoint = bouncePoint;
           }
           
           //Then return the closer bounce point.
           
           return closestPoint;
           
       }
       return null;
  }
  
  /**
  * This method returns true if pointA exists and is closer to the ball than pointB.
  * @author Mathieu Bissonnette
  */
  
  private boolean isCloser(BouncePoint pointA, BouncePoint pointB) {
       // Verify if one of the point is null.
       if (pointA == null) {
           return false;
       }
       if (pointB == null) {
           return true;
       }   
       // Calculate the distances and check for the smallest one.
       double distanceA = Math.sqrt(Math.pow(currentBallX-pointA.getX(), 2) + Math.pow(currentBallY-pointA.getY(), 2));
       double distanceB = Math.sqrt(Math.pow(currentBallX-pointB.getX(), 2) + Math.pow(currentBallY-pointB.getY(), 2));
       return (distanceA < distanceB);
  }

 /*Method if the ball doesn't hit anything and stays in bounds
  @author Imane Chafi
  */

   private void doHitNothingAndNotOutOfBounds(){
    double x = this.getCurrentBallX();
    double y = this.getCurrentBallY();
    double dx = this.getBallDirectionX();
    double dy = this.getBallDirectionY();
    this.setCurrentBallX(x+dx);
    this.setCurrentBallY(y+dy);
  }

  /**
   * This performs all the required actions for ending the game.
   * @author Georges Mourant
  */
  private void doGameOver() {
    block223 = getBlock223();
    Player p = getPlayer();
    if(p != null){
      game = getGame();
      HallOfFameEntry hofe = new HallOfFameEntry(score, playername, p, game, block223);
      game.setMostRecentEntry(hofe);
    }
    delete();
  }

  // Guard Helper methods

  /**
   * This returns true if the ball is out of bounds.
   * @author Georges Mourant
   * @return if ball is out of bounds
  */
  private boolean isBallOutOfBounds(){
    double ballBottomY = getCurrentBallY() + Ball.BALL_DIAMETER;
    double paddleTopY = getCurrentPaddleY();
    return (paddleTopY > ballBottomY);
  }
  
}
